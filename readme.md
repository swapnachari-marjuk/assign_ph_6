# Answer to the given question: Assignment 6

## Ans. to the Ques. no. 1

**Difference between var & let,const**

    1. `var` : `var` হলো ES6 পূর্ববর্তী একটি কি-ওয়ার্ড যা দ্বারা ভেরিয়েবল ডিক্লেয়ার করা হয়।
             *এটি হোস্টেড হয় যার ফলে ডিকলারের পূর্বেই কল করা যায়। তবে কনসোল লগে আনডিফাইন্ড আসে।
             *এটি যদি কোনো স্কোপের ভিতর ডিকলেয়ার করা হয় তবে তা বাইরে থেকেও কল করা যায়। (ফাংশন স্কোপ ছাড়া)
             *এটিকে একটি স্কোপে বার বার রিডিকলেয়ার এবং রিএসাইন করা যায়।

    2. `let` & `const`: `let` & const হলো ES6এ আপডেটকৃত একটি কি-ওয়ার্ড যা দ্বারা ভেরিয়েবল ডিক্লেয়ার  করা হয়।
            *এগুলোও হোস্টেড হয় ডিকলারের পূর্বেই কল করা যায় না। কল করলে "Temporal Dead Zone" (TDZ) পড়ে যায় এবং এরর দিয়ে দেয়।
            *এগুলোকে যদি কোনো স্কোপের ভিতর ডিকলেয়ার করা হয় তবে তা বাইরে থেকে আর কল করা যায় না।
            *`let`কে কোনো একটি স্কোপের ভিতর রিডিকলেয়ার করা যায় না কিন্তু রিএসাইন করা যায় । তবে `const`কে রিডিকলেয়ার কিংবা রিএসাইন কিছুই করা যায় না।

## Ans. to the Ques. no. 2

**Difference between map, forEach, filter**

    `map, forEach, filter` এগুলো সবগুলোই অ্যারে ম্যাথড যেগুলো নির্দিষ্ট উদ্দেশ্যে লুপ চালানোর জন্য ব্যবহৃত হয়। তবে এগুলোর আচরণ ও উদ্দেশ্য অনেকটাই আলাদা আলাদা। 
    *`map` একটি অ্যারের উপর লুপ চালিয়ে নতুন একটি অ্যারেতে মূল অ্যারের প্রোপার্টিগুলোকে সাজিয়ে রিটার্ন করে। এইটা সাধারণত কোনো অ্যারের প্রোপার্টিগুলোর উপর কোনো কাজ করতে চাইলে (যেমনঃ গুন, ভাগ, ইত্যাদি) ব্যবহৃত হয়।
    *`forEach`ও `map` এর মতো করেই একটি অ্যারের উপর লুপ চালায়। তবে এটা প্রোপার্টিগুলোকে রিটার্ন করে না। সাধারণত অ্যারের প্রোপার্টিগুলোর উপর কোনো কাজ করে যদি তার রিটার্ন নিতে না চায় তাহলে এইটা ব্যবহৃত হয়। 
    *`filter` একটি অ্যারের উপর লুপ চালায় ঠিকই তবে তা রিটার্ন করতে একটি নির্দিষ্ট কন্ডিশন চায় এবং ওই কন্ডিশন যে যে প্রোপার্টি ফুলফিল করে সেগুলোকেই একটি নতুন অ্যারেতে রিটার্ন করে।

## Ans. to the Ques. no. 3

**Arrow function & its prominency**

    Arrow function হল ES6 এর একটি নতুন ফিচার যা দ্বারা `function` কিওয়ার্ড লেখা ছাড়াই সংক্ষেপে ফাংশন ডিকলেয়ার করা যায়। এছাড়া--
    *এক লাইনের কোড লিখতে Arrow function-এ `{}` এবং `return` লিখতে হয় না।
    *Arrow function-এর মধ্যে ডায়নামিক `this` নেই। বরং লেক্সিক্যালভাবে বাইন্ড করতে হয়। 
    *Arrow function-এর মধ্যে `arguments` object নেই। বরং এখানে সবগুলো আর্গুমেন্টস পাস করতে রেস্ট অপারেটরের (...) ব্যবহার করতে হয়।

## Ans. to the Ques. no. 4

**Destructuring assignment in ES6**
     
    Destructuring assignment-ও ES6-এ আসে জাভাস্ক্রিপ্টে। এর দ্বারা অ্যারে ও অবজেক্ট থেকে ডাটা এক্সেস করা যায় খুব সহজেই। 
    * অ্যারে থেকে ভ্যালু এক্সেস করা হয় নিচের পদ্ধতিতে-
     `let members = ["Ahmad", "Hammad", "Sajjad"]`
     `let [first, second, third] = members`
     Output of `first` will be Ahmad.
     Output of `second` will be Hammad.
     (এছাড়া স্প্রেড অপারেটর`...` দিয়েও করা যায় কিছু ক্ষেত্রে।)

    * Object থেকে ভ্যালু এক্সেস করা হয় নিচের পদ্ধতিতে-
        `const person = { name: 'Ahmad', age: 19 };`
        `const { name, age } = person;`
        `console.log(name); // 'Ahmad'`
        `console.log(age); // 19`
      এছাড়া নতুন একটি ডিফল্ট ভ্যালু অ্যাড করা যায়। যেমনঃ
        `const { name, age, address:"Lakshmipur" } = person;`
        `console.log(address) // Lakshmipur 

## Ans. to the Ques. no. 5

**Template literals in ES6**

    Template literals-ও (``/এই সিম্বলটি ব্যাকটিক নামেও সাধারণত পরিচিত) ES6-এ আসে জাভাস্ক্রিপ্টে। এর দ্বারা মাল্টি লাইন স্ট্রিং একেবারেই লেখা যায়। যা আগে প্রতি লাইনের শেষে একবার করে `\n` লেখা লাগত। এছাড়া ডায়নামিক কোনো কিছু লেখতেও এখন শুধু মাত্র Template literals-এর ভিতর ${} দিয়েই লিখে ফেলা যায় যা আগে অনেক কঠিন ও বাড়তি সিনট্যাক্স লিখে লেখা লাগত।